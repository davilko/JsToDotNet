// START
program             = sourceElement? EOF
sourceElement       = import | statement
import              = "import" namespace
namespace           = identifier ("." identifier)?

// TYPES
typeAlias           = "type" identifier typeParameters? "=" type 
typeParameters      = "<" typeParameterList ">"
typeParameterList   = type ("," type)*
typeArguments       = typeParameters

typeAnnotation      = ":" type

type                = union | functionType | primaryType 

union               = primaryType | primaryType
                        
primaryType         = predefinedType | typeReference | objectType | arrayType

predefinedType      = 'any'
                       | 'number'
                       | 'boolean'
                       | 'string'
                       | 'void'

typeReference       = typeName (typeArguments)?
typeName            = identifier | namespace

functionType        = typeParameters? '(' parameterList? ')' '=>' type
objectType          = "{" typeBody? "}"
typeBody            = propertySignatur 
propertySignatur    = identifier '?'? typeAnnotation?

statement           =  block
                        | variableStatement
                        | emptyStatement
                        | classDeclaration
                        | expressionStatement
                        | ifStatement
                        | iterationStatement
                        | continueStatement
                        | breakStatement
                        | returnStatement
                        | switchStatement
                        | throwStatement
                        | tryStatement
                        | debuggerStatement
                        | functionDeclaration
                                         
block               = "{" statementList? "}"
statementList       = statement+

// LET & VAR
variableStatement   = varModifier identifier typeAnnotation? "=" singleExpression
varModifier         = "let" | "var" | "const"

// CLASS
classDeclaration    = "class" identifier ("extends" identifier)? "{" classElement* "}"
classElement        = ("static")? methodDefinition
methodDefinition    = identifier "(" parameterList? ")" "{" functionBody "}"

// STMT
ifStatement         = "if" "(" singleExpression ")" ("else" statement)?
iterationStatement  = forIteration | whileIteration
whileIteration      = "while" "(" singleExpression ")" "{" statement? "}"
forIteration        = "for" "(" singleExpression? ";" singleExpression? ";" singleExpression? ";" ")" statement
continueStatement   = "continue"
breakStatement      = "break"
returnStatement     = "return" (singleExpression)?
switchStatement     = "switch" "(" singleExpression ")" "{" caseBlock "}"
caseBlock           = caseClauses? (defaultClause caseClauses?)?
caseClauses         = caseClause+
caseClause          = "case" ":" statement
defaultClause       = "default" ":" statement

// ERRORS
throwStatement      = "throw" singleExpression
tryStatement        = "try" block (catchProduction finallyProduction? | finallyProduction)
catchProduction     = "catch" "(" identifier ")" block
finallyProduction   = "finally" block

// FUNCTION
functionDeclaration = "function" identifier typeParameters? "(" parameterList? ")" "{" functionBody "}"
parameterList       = simpleArgs ("," simpleArgs)* restArgs?
simpleArgs          = identifier typeAnnotation? ("=" singleExpression)?
restArgs            = "..." identifier typeAnnotation?
functionBody        = statement?

// MEMBER ACCESSOR
memberIndexExpression  = identifier "[" singleExpression "]"
memberAccessExpression  = identifier "." identifier

// INITIALIZERS
newExpression              = newObjectLiteralExpression 
                            | newArrayLiteralExpression
                            | ("new" (newArrayExpression | newClassExpression))
                            
newArrayExpression         = "Array" typeParameters? "(" ")"
newClassExpression         = identifier "(" parameterList? ")"
newObjectLiteralExpression = "{" (propertyAssignment ("," propertyAssignment)*)? ","? "}"
propertyAssignment         = simplePropertyAssignment | computedPropertyAssignment
simplePropertyAssignment   = identifier ":" singleExpression
computedPropertyAssignment = "[" singleExpression "]" ":" singleExpression
newArrayLiteralExpression  = "[" sequenceExpression? "]"

// OPERATIONS
operatorExpression         = postIncrementExpression
                           | postIncrementExpression
                           | deleteExpression
                           | typeOfExpression
                           | instanceofExpression
                           | unaryMinusExpression
                           | bitNotExpression
                           | notExpression
                           | additiveExpression
                           | inExpression
                           | equalityExpression
                           | logicalAndExpression
                           | logicalOrExpression
                           | ternaryExpression
                           | assignmentExpression
                           
postIncrementExpression    = singleExpression "++"
postDecreaseExpression     = singleExpression "--"
deleteExpression           = Delete identifier
typeOfExpression           = Typeof singleExpression
instanceofExpression       = singleExpression Instanceof singleExpression
unaryMinusExpression       = "-"
bitNotExpression           = "~"
notExpression              = "!"
additiveExpression         = ("+" | "-")
inExpression               = singleExpression In singleExpression
equalityExpression         = singleExpression ("==" | "!=" | "===" | "!==") singleExpression
logicalAndExpression       = singleExpression "&&" singleExpression 
logicalOrExpression        = singleExpression "||" singleExpression 
ternaryExpression          = singleExpression "?" singleExpression ":" singleExpression 
assignmentExpression       = singleExpression "=" singleExpression 

// 
thisExpression             = This 
identifierExpression       = Identifier 


sequenceExpression = singleExpression (','+ singleExpression)*

singleExpression   = memberIndexExpression
                   | memberAccessExpression
                   | newExpression
                   | operatorExpression
                   | thisExpression
                   | identifierExpression
                    